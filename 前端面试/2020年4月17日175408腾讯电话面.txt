python知道哪些数据结构
原始数据结构:Python有四种原始变量类型：Integers 、Float、Strings、Boolean
非原始数据结构:
非原始数据结构的数据关系更加复杂，主要包括：Arrays、Lists、Files、tuple
元组是另一种标准序列数据类型。 元组和列表之间的区别在于元组是不可变的，这意味着一旦定义，您就无法删除，添加或编辑其中的任何值
lists中线性数据结构：栈（pop（）、append（））和队列
lists中非线性数据结构：树（tree）和图（Graphs）
Sets：集合可变
集合是唯一对象的集合。 这些对于创建仅在数据集中包含唯一值的列表很有用。 它是一个无序的集合，但是一个可变的集合
-----------------------------
可变数据，不可变数据结构
python中数据类型有：整型，字符串，元组，集合，列表，字典
不可变数据类型：整型，字符串，元组
可变数据类型：集合，列表，字典
======================================

django ORM
什么是 ORM？
ORM （Object Realtional Mapping）即对象关系映射，它是一种基于关系型数据库的程序技术
ORM：类、对象、属性
对应于DB：数据表、数据行、字段
------------------
Django 把表模型定义为 Model，他需要继承自 django.db.models中的 Model 类，只要是与数据表相关的操作，都需要继承这个类。同时ORM 对于数据库的的增删改查，也提供了一些简单的 API，例如 F 查询、Q 查询。
针对数据库中的字段类型，Django ORM 都有对应的 “xxxField” 来表述
--------------------------------
ORM 的增删改查称为 CURD 操作，下面列举几个常用语句： 
UserInfo.objects.all()#查询表中的所有记录
UserInfo.objects.filter(name_contains='j')#查询表中name含有“j”的所有记录,被使用较多
UserInfo.objects.get(name="john")#有且只有一个查询结果，如果超出一个或者没有,则抛出异常
UserInfo.objects.get(name="john").delete()#删除名字为john的记录
UserInfo.objects.get(name="john").update(name='TOM')#更新数据表的name为TOM
===========================================
mvvm 的概念
在MVVM模式中，View封装UI和UI逻辑，viewmodel封装presentation逻辑（定义view所需要的数据，协调view和所需model的交互），model封装业务逻辑和数据（简单来说就是数据）。
---------------------------------
vue中的mvvm
view(DOM)<---->view model(vue的dom监听，数据绑定)<---->model (js objects)
==========================================

反爬虫的相关知识
常见的反爬虫和应对方法:
1）.通过Headers反爬虫
从用户请求的Headers反爬虫是最常见的反爬虫策略。很多网站都会对Headers的User-Agent进行检测，还有一部分网站会对Referer进行检测（一些资源网站的防盗链就是检测Referer）。
此反爬虫应对方法：
以直接在爬虫中添加Headers，将浏览器的User-Agent复制到爬虫的Headers中；
或者将Referer值修改为目标网站域名。
对于检测Headers的反爬虫，在爬虫中修改或者添加Headers就能很好的绕过。
---------------------------------
2）.基于用户行为反爬虫
还有一部分网站是通过检测用户行为，例如同一IP短时间内多次访问同一页面，或者同一账户短时间内多次进行相同操作
此反爬虫应对方法：
大多数网站都是前一种情况，对于这种情况，使用IP代理就可以解决。可以专门写一个爬虫，爬取网上公开的代理ip，检测后全部保存起来。这样的代理ip爬虫经常会用到，最好自己准备一个。有了大量代理ip后可以每请求几次更换一个ip，这在requests或者urllib2中很容易做到，这样就能很容易的绕过第一种反爬虫。
对于第二种情况，可以在每次请求后随机间隔几秒再进行下一次请求。有些有逻辑漏洞的网站，可以通过请求几次，退出登录，重新登录，继续请求来绕过同一账号短时间内不能多次进行相同请求的限制。
---------------------------------
3）.动态页面的反爬虫
还有一部分网站，我们需要爬取的数据是通过ajax请求得到，或者通过JavaScript生成的。首先用Fiddler对网络请求进行分析。如果能够找到ajax请求，也能分析出具体的参数和响应的具体含义，我们就能采用上面的方法，直接利用requests或者urllib2模拟ajax请求，对响应的json进行分析得到需要的数据。
----------------
但是有些网站把ajax请求的所有参数全部加密了。我们根本没办法构造自己所需要的数据的请求。这种情况下就用selenium+phantomJS，调用浏览器内核，并利用phantomJS执行js来模拟人为操作以及触发页面中的js脚本。从填写表单到点击按钮再到滚动页面，全部都可以模拟，不考虑具体的请求和响应过程，只是完完整整的把人浏览页面获取数据的过程模拟一遍。
phantomJS就是一个没有界面的浏览器，只是操控这个浏览器的不是人。利selenium+phantomJS能干很多事情，例如识别点触式（12306）或者滑动式的验证码，对页面表单进行暴力破解等
=================================

linux find相关知识
find的 一些命令的使用    
  查找linux系统下条件满足以sh结尾，30天没有修改的文件，大小大于10K同时具有执行权限的文件并备   份到/data/backup/目录下。 

访问时间（-atime/天，-amin/分钟）：用户最近一次访问时间。 
修改时间（-mtime/天，-mmin/分钟）：文件最后一次修改时间。 
变化时间（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。

find /  -type 类型参数 
 f  普通文件 
 l  链接文件
 d  目录文件 
 b  块设备
 c  字符设备
 s  套接字
 搜索大于10KB的文件 find . -type f -size +10k 
 搜索小于10KB的文件 find . -type f -size -10k
 搜索等于10KB的文件 find . -type f -size 10k

 根据文件权限/所有权进行匹配
 当前目录下搜索出权限为777的文件        find . -type f -perm 777 
 找出当前目录下权限不是644的php文件    find . -type f -name "*.php" ! -perm 644 
 找出当前目录用户tom拥有的所有文件     find . -type f -user tom 
 找出当前目录用户组sunk拥有的所有文件  find . -type f -group sunk
  
  借助-exec选项与其他命令结合使用 
找出当前目录下所有root的文件，并把所有权更改为用户tom 
find .-type f -user root -exec chown tom {} \; 
上例中，{} 用于与-exec选项结合使用来匹配所有文件，然后会被替换为相应的文件名。

find  /（此处接目录） -name “*sh” -mtime +30 -size +10k -perma=x -exec cp {} /data/backup/ \;
------------------------------------
限制搜索深度 ： -maxdepth2   ；  -mindepth 2 
根据文件大小：通过-size来过滤文件尺寸
举例来说，找出当前目录下文件大小超过100M的文件
find . -type f -size +100M 
将日志目录里超过一个礼拜的日志文件，移动到/tmp/old_logs里。
find . -type f -mtime +7 -name "*.log" -exec mv {} /tmp/old_logs \; 
注意：{} 用于与-exec选项结合使用来匹配所有文件，然后会被替换为相应的文件名。
另外，\;用来表示命令结束，如果没有加，则会有如下提示
find: -exec: no terminating ";" or "+" 
根据权限
通过-perm来实现。举例，找出当前目录下权限为777的文件
find . -type f -perm 777 
找出当前目录下权限不是644的php文件
find . -type f -name "*.php" ! -perm 644 
根据文件拥有者
找出文件拥有者为root的文件
find . -type f -user root 
找出文件所在群组为root的文件
find . -type f -group root 
找到文件后执行命令
通过-ok、和-exec来实现。区别在于，-ok在执行命令前，会进行二次确认，-exec不会。
============================

vue v-if 和 v-show 区别
（1）手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；
（2）编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；
（3）编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；
（4）性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；

------------------------------
v-if 和 v-show 的使用场景
一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。
因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。
===================================
v-if适合运营条件不大可能改变；v-show适合频繁切换。
（1）对于管理系统的权限列表的展示，这里可以使用v-if来渲染，如果使用到v-show，对于用户没有的权限，在网页的源码中，仍然能够显示出该权限，如果用v-if，网页的源码中就不会显示出该权限。（在前后台分离情况下，后台不负责渲染页面的场景。）
（2）对于前台页面的数据展示，这里推荐使用v-show，这样可以减少开发中不必要的麻烦。
================================================
服务器 wsgi的了解
WSGI(Python Web Server Gateway Interface)就是Python的CGI包装,为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。
================================================

数据库的相关知识（mysql）
mysql 读写数据都需要从磁盘读取 。磁盘的容量，带宽的大小就影响了网站的访问速度，读取的方式，也就是 sql 语句，次数和效率也会影响读取效率。
当访问量和并发很大的时候，mysql 就撑不住了，据统计，mysql的连接池并发数max为 500-1000
这时，我们可以通过 慢查询优化 ，cdn ,页面静态化, nginx 负载均衡策略 ，甚至 分布式数据库 来进行 sql优化 ，当然也可以使用 高速缓存，比如 redis。
-----------------------------------
mysql 和redis的区别
redis是NOSQL，即非关系型数据库，也是缓存数据库，即将数据存储在缓存中，缓存的读取速度快，能够大大的提高运行效率，但是保存时间有限。
mysql作为持久化存储的关系型数据库，相对薄弱的地方在于每次请求访问数据库时，都存在着I/O操作，如果反复频繁的访问数据库。第一：会在反复链接数据库上花费大量时间，从而导致运行效率过慢；第二：反复的访问数据库也会导致数据库的负载过高，那么此时缓存的概念就衍生了出来。
----------------------
redis和mysql的区别总结
（1）类型上
从类型上来说，mysql是关系型数据库，redis是缓存数据库
（2）作用上
mysql用于持久化的存储数据到硬盘，功能强大，但是速度较慢
redis用于存储使用较为频繁的数据到缓存中，读取速度快
（3）需求上
mysql和redis因为需求的不同，一般都是配合使用。

